# Gradle이란?
* 오픈 소스 빌드 자동화 도구로, 빌드하려는 대상이나 빌드 방법을 고정하지 않아 유연함
* 특정 프로그래밍 언어나 플랫폼에 종속되지 않음

## 빌드 스크립트
* gradle이 빌드하는 것이 프로젝트, 프로젝트에는 빌드 스크립트가 포함됨
* 빌드 스크립트는 일반적으로 프로젝트의 루트 디렉토리에 있는 build.gradle 라는 이름의 파일
* 빌드 스크립트는 해당 프로젝트에 대한 태스크, 의존성, 플러그인 등 구성을 정의함
* 하나의 gradle 빌드에서 여러 개의 프로젝트를 관리할 수 있음


## Gradle Wrapper
* Gradle을 설치하지 않고도 Gradle을 실행할 수 있도록 해주는 스크립트로, 해당 프로젝트에서 필요한 Gradle 버전을 자동으로 다운로드하고 사용함
* gradlew와 gradlew.bat은 Gradle Wrapper의 일부로, Gradle 빌드를 자동화하고 관리하는 데 도움을 주는 스크립트
* gradlew는 Unix, Linux, macOS와 같은 유닉스 계열 운영체제에서 사용되는 Gradle Wrapper 스크립트
* gradlew.bat은 Windows 운영체제에서 사용하는 Gradle Wrapper 스크립트

## Gradle 빌드 설정 파일
* settings.gradle은 Gradle 빌드 설정 파일 중 하나로, Gradle 프로젝트에 대해 전역적인 설정을 제공하는 역할
* 프로젝트의 구성과 빌드를 조정하는 데 필요한 설정을 포함함
* 특정 플러그인을 적용하거나, 전역 설정을 추가할 수 있음
    ex) 멀티 프로젝트 빌드의 경우, 하위 프로젝트에서 공통적으로 사용할 설정을 추가할 수 있음
* 프로젝트 내의 모듈 간 의존성을 정의하고, 필요한 플러그인이나 리포지토리 등을 설정할 수 있음
* settings.gradle은 주로 프로젝트의 구조와 설정을 정의하는 파일로, 멀티 프로젝트 빌드를 구성하고 하위 프로젝트를 정의하는 데 사용됨
* settings.gradle은 빌드가 시작되기 전에 Gradle이 먼저 읽고 평가함
* build.gradle은 각 개별 프로젝트(또는 하위 프로젝트)의 빌드 설정을 정의하는 파일로, 의존성, 플러그인, 태스크 등을 설정함 settings.gradle이랑은 조금 다름

## 태스크
* 코드 컴파일, 테스트 실행, 빌드, 소프트웨어 배포 등 프로젝트에서 실행할 수 있는 하나의 작업 단위
* 프로젝트는 여러 개의 태스크로 구성되며, 여러 개의 태스크를 조합해서 빌드 프로세스를 정의할 수 있음
* 태스크의 구성은 다음과 같음
    > 액션: 파일 복사 또는 소스 컴파일과 같은 작업을 수행하는 작업 단위, 태스크가 실행하는 코드
    
    > 입력: 액션이 사용하거나 작업하는 값, 파일 및 디렉터리, 태스크 실행에 필요한 값
    
    > 출력: 액션이 수정하거나 생성하는 파일 및 디렉터리, 태스크 실행 결과로 생성되는 파일

## 플러그인
* 여러 프로젝트에서 로직과 구성을 재사용할 수 있는 수단을 제공함
* 플러그인을 사용하면 한번 작성된 태스크를 여러 빌드에서 사용할 수 있음
* 로깅, 의존성, 버전 관리와 같이 일반적으로 사용되는 구성을 한 곳에 저장할 수도 있음
* 빌드 스크립트의 중복을 줄일 수 있어 편의성과 효율성을 크게 향상시킬 수 있음
* 플러그인을 확인한다는 것은 해당 플러그인이 포함된 올바른 버전의 jar를 찾아 스크립트 클래스 경로에 추가하는 것을 의미함
* Gradle에서 플러그인을 적용하면 그 플러그인이 제공하는 기능(API)을 빌드 스크립트에서 사용할 수 있음
    ex) java 플러그인을 적용하면 컴파일, 테스트, JAR 생성 등 여러 API를 사용할 수 있음

## 의존성
* 프로젝트에서 외부 라이브러리, 프레임워크, 모듈 등을 사용할 때, 이 코드들이 프로젝트에서 필요한 구성 요소가 되면 이를 의존성이라고 함
* 의존성 관리를 통해 의존성을 자동화된 방식으로 선언하고, 해결하고, 사용할 수 있음
* 의존성 해결은 프로젝트에서 필요한 라이브러리를 자동으로 다운로드하고, 올바른 버전을 가져와서 사용할 수 있도록 만드는 과정을 말함

## 의존성 관리
* 프로젝트 코드가 빌드될 때 의존성 모듈도 함께 빌드될 수 있도록 Gradle에 해당 모듈을 찾을 수 있는 위치를 알려주어야 함
* 여기서 모듈을 저장하는 위치를 리포지토리라고 함
* 빌드에 대한 리포지토리를 선언하면 Gradle은 모듈을 찾고 검색함
* 설정한 리포지토리를 확인하고 의존성에서 선언된 라이브러리를 찾고, 각 저장소를 검색해 해당 라이브러리를 찾아서 사장 적절한 버전을 선택하고 다운해서 로컬 캐시에 저장함
* 다시 다운로드 하지 않도록 로컬 캐시에 저장해서 최적화 하는 것
* 리포지토리는 로컬 디렉토리 또는 원격 리포지토리 등 다양한 형태로 제공될 수 있음


## 의존성 해결
* 런타임에 Gradle은 선언된 의존성 찾고, 원격 저장소에서 다운로드하거나 로컬 디렉토리에서 검색하거나 멀티 프로젝트 설정에서 다른 프로젝트를 빌드할 수도 있음
* 이 프로세스를 의존성 해결이라고 함
* 의존성이 해결되면 해결 메커니즘은 의존성의 기본 파일을 의존성 캐시라고도 하는 로컬 캐시에 저장함
* 향후 빌드에서는 불필요한 네트워크 호출을 피하기 위해 캐시에 저장된 파일을 재사용함

## 의존성 구성
* Gradle 프로젝트에 선언된 모든 의존성은 특정 범위에만 적용됨
    ex) implementation, api, compileOnly, runtimeOnly, testImplementation 등 구성에서 의존성 범위가 다 다름 
* Gradle은 구성을 통해 의존성의 범위를 명시하는데, 모든 구성은 고유한 이름으로 식별할 수 있음
* 많은 Gradle 플러그인은 프로젝트에 사전 정의된 구성을 추가함
    ex) java 플러그인은 소스 코드 컴파일, 테스트 실행 등에 필요한 다양한 클래스 경로를 나타내는 구성을 추가함

## 구성 상속 및 확장
* 구성은 다른 구성을 확장하여 상속 계층 구조를 형성할 수 있음
* 하위 구성은 상위 구성에 대해 선언된 전체 의존성 집합을 상속함
    ex) api가 implementation을 상속
* 구성 상속은 Java 플러그인과 같은 Gradle 핵심 플러그인에서 많이 사용됨
    ex) testImplementation은 implementation 구성을 확장 (테스트를 컴파일하려면 테스트 클래스를 작성하는 데 필요한 의존성 위에 테스트 대상 소스 코드의 의존성이 필요하기 때문)

## 의존성 선언
* DependencyHandler는 의존성을 선언하는 데 사용됨
* DependencyHandler는 dependencies 블록 내에서 사용됨
* 의존성을 프로젝트에 추가할 때 Gradle이 이 객체를 통해 의존성을 관리하고 처리
* dependencies 블록 내에서 의존성을 추가할 때 Gradle은 내부적으로 DependencyHandler를 사용하여 의존성을 처리한다는 뜻
* 의존성을 선언할 때 구성(configuration) 과 의존성(artifact)을 연결해주는 역할을 함
* 의존성은 구성으로 그룹화됨
    ex) implementation과 testImplementation은 구성이고 각각의 의존성들은 특정 구성을 기준으로 그룹화 된 것
* 그룹화를 통해 Gradle은 각각의 의존성이 어느 시점에 필요한지, 어떤 목적을 위해 사용되는지 알 수 있음

## 빌드 단계
* Gradle은 세 단계에서 빌드 스크립트를 평가하고 실행함
    > 초기화: 설정 파일을 평가하여 어떤 프로젝트와 빌드가 빌드에 포함되는지 결정
    
    > 구성: 요청된 태스크에 대한 태스크 그래프를 생성, 사용자가 실행하려는 태스크에 따라 어떤 태스크를 어떤 순서로 실행해야 하는지 결정
    + 태스크 그래프: Gradle에서 어떤 태스크가 실행될지, 그리고 그 순서는 어떻게 되는지에 대한 구조를 나타내는 것으로, 태스크들이 어떻게 의존하고 연결되어 있는지, 어떤 태스크가 먼저 실행되고, 어떤 태스크가 그 후에 실행될지를 나타내는 그래프
    > 실행: 선택된 태스크들을 의존성 순서대로 예약하고 실행

## 빌드
* Gradle 프로젝트에서 태스크들을 실행하는 것
* Gradle은 빌드를 구성하고 실행할 태스크를 선택
* 요청된 태스크와 해당 의존성을 기반으로 가장 작은 태스크 집합을 실행
* 모든 태스크를 실행하지 않고, 필요한 태스크들만 실행한다는 것