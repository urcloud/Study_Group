# 동시성 제어

## 비관 락
* 항상 충돌이 발생할 것이라 가정하고, 데이터를 읽거나 쓰기 전 선제적으로 락을 걸음
* 비관 락의 경우, DBMS가 주요 주체임 
* 다른 트랜잭션이 이 데이터를 변경하지 못하게 강제적으로 차단함
* 비관 락은 트랜잭션 수준에서 관리됨 
* 데이터베이스가 동시성 문제를 해결하기 위해 특정 데이터를 잠그고, 트랜잭션이 데이터를 처리하는 동안 다른 트랜잭션이 해당 데이터를 수정하지 못하게 함

> ex) 동작과정 예시
> 
> 트랜잭션 A가 상품 재고를 수정하려고 DB에서 SELECT ... FOR UPDATE로 데이터를 읽음
> 
> 이 순간 해당 row에 락이 걸림
> 
> 트랜잭션 B는 동일한 row에 접근하려 하면 대기하거나 실패
> 
> 트랜잭션 A가 커밋하거나 롤백하면 락이 해제되고, 이후 B가 진행됨


## 낙관 락
* 충돌이 자주 일어나지 않을 것이라 가정
* 데이터에 버전(version) 을 두고, 변경 시점에 충돌이 발생했는지를 확인하여 충돌 시 예외 발생
* 락을 걸지 않지만, 저장 시점에 변경 여부를 체크함
* 낙관 락의 경우, 애플리케이션이 주요 주체임 (JPA에서는 @Version 어노테이션으로 사용)
* 데이터베이스가 아니라 애플리케이션 코드에서 관리됨 
* 낙관적 가정에 기반하여 동시성 문제를 해결하며, 여러 트랜잭션이 동시에 데이터를 수정할 확률이 낮다고 보고 잠금 없이 진행하고 데이터 충돌이 발생할 경우에만 해결 방법을 찾음

> ex) 동작과정 예시
>
> 트랜잭션 A와 B가 version = 1인 데이터를 동시에 읽음
>
> A가 stock을 수정하고 저장 시, version이 1이므로 성공하고 version이 2로 올라감
>
> B도 stock을 수정하고 저장하려고 시도하지만, 현재 DB에 있는 version이 2이므로 충돌 발생


## 분산 락
* 여러 서버나 시스템에서 동일 자원에 접근할 경우, 이를 조율하기 위한 락
* Redis와 같은 분산 시스템이 주요 주체임 
* 락 획득 시 주체가 락 키를 생성하고, 락 해제 시 자신이 소유자일 경우만 해제함
* 중앙 저장소 (Redis, Zookeeper, DB 등)에 락 정보를 저장하여 분산 환경에서 락을 구현
* 분산 락은 여러 서버가 있을 때, 공유 자원에 접근하기 위해 분산 시스템을 통해 락을 관리함 
* 데이터베이스나 애플리케이션에서 관리하는 락과는 달리, 분산 환경에서 락을 걸고 풀 수 있는 기능을 제공하는 시스템을 사용함

> ex) 동작과정 예시
> 
> 서버 A가 Redis에 lock:product:1 키를 생성 (SET lock:product:1 <UUID> NX PX 3000)
> 
> 락 획득에 성공하면 작업 수행
>
> 서버 B는 동일한 키를 SET하려 하지만 실패하고 재시도
>
> 서버 A는 작업을 마치고 락 키를 제거함