# 동시성 제어

## 비관 락
* 트랜잭션 시작 시점에 해당 데이터를 다른 트랜잭션이 접근하지 못하도록 DB 차원에서 락을 거는 방식
* 항상 충돌이 발생할 것이라 가정하고, 데이터를 읽거나 쓰기 전 선제적으로 락을 걸음
* 비관 락의 경우, DBMS가 주요 주체임 
* 다른 트랜잭션이 이 데이터를 변경하지 못하게 강제적으로 차단함
* 데이터베이스가 동시성 문제를 해결하기 위해 특정 데이터를 잠그고, 트랜잭션이 데이터를 처리하는 동안 다른 트랜잭션이 해당 데이터를 수정하지 못하게 함

> ex) 동작과정 예시
> 
> 트랜잭션(데이터베이스에서 하나의 작업 단위) 시작
>
> SELECT ... FOR UPDATE 같은 쿼리로 해당 행에 쓰기 락 획득 (수정할 권한을 먼저 가져가는 것)
>
> 데이터베이스는 해당 행에 락을 걸고, 다른 트랜잭션이 못 건드리도록 잠금 상태로 만듦
> 
> 다른 트랜잭션은 해당 행을 읽거나 수정 불가(대기) 상태
>
> 재고 감소 후 커밋 혹은 롤백
> 
> 락 해제됨 → 다른 트랜잭션 진행 가능
> 
> 하나의 데이터에 대해 동시에 두 개 이상의 트랜잭션이 쓰기 작업 못함
>
> 락이 해제될 때까지 나머지는 대기열에서 기다림
>
> 락 해제 → 다음 트랜잭션이 락 획득 → 작업 진행 → 락 해제 → ...
>
> 이렇게 순차적으로 하나씩 처리됨


## 낙관 락
* 충돌이 자주 일어나지 않을 것이라 가정
* 데이터에 버전(version) 을 두고, 변경 시점에 충돌이 발생했는지를 확인하여 충돌 시 예외 발생
* 락을 걸지 않지만, 저장 시점에 변경 여부를 체크함
* 낙관 락의 경우, 애플리케이션이 주요 주체임 (JPA에서는 @Version 어노테이션으로 사용)
* 데이터베이스가 아니라 애플리케이션 코드에서 관리됨 
* 낙관적 가정에 기반하여 동시성 문제를 해결하며, 여러 트랜잭션이 동시에 데이터를 수정할 확률이 낮다고 보고 잠금 없이 진행하고 데이터 충돌이 발생할 경우에만 해결 방법을 찾음

> ex) 동작과정 예시
>
> 트랜잭션 시작
>
> 데이터를 읽고 메모리에 저장
>
> 변경 후 저장 (UPDATE ... WHERE version = ?)
>
> DB에서 version 비교 → 일치 시 update, 불일치 시 OptimisticLockingFailureException 발생
>
> 실패 시 재시도 필요
> 
> 데이터에 버전 번호(예: 정수값)를 추가해서 관리
>
> 데이터가 수정될 때마다 버전 번호가 1씩 증가
>
> 트랜잭션이 데이터를 읽을 때 그 버전 번호도 같이 읽음
> 
> 트랜잭션 A가 데이터와 함께 현재 버전(예: version = 3)을 읽음
>
> 트랜잭션 A는 필요한 작업을 수행함 (예: 화면에서 사용자 수정)
>
> 트랜잭션 A가 데이터를 저장하려고 할 때, DB에 저장된 버전이 여전히 3인지 확인
>
> 만약 DB 버전이 3이면, 수정 허용 → 버전을 4로 업데이트
>
> 만약 DB 버전이 이미 4 이상으로 변경되어 있다면 → 충돌 발생, 수정 실패 (다른 트랜잭션이 먼저 수정한 것)
> 
> @Version 어노테이션 붙은 필드가 버전 관리용, JPA가 자동으로 버전 비교와 업데이트를 처리해줌
>
> ex) ```@Version
    private Integer version;```
>
> 작업 전 버전을 읽고
>
> 작업 후 저장 시점에 버전이 같은지 검사 → 같으면 업데이트 + 버전 1 증가
>
> 버전이 다르면 충돌 발생 → 수정 실패


## 분산 락
* 여러 서버나 시스템에서 동일 자원에 접근할 경우, 이를 조율하기 위한 락
* Redis와 같은 분산 시스템이 주요 주체임 
* 락 획득 시 주체가 락 키를 생성하고, 락 해제 시 자신이 소유자일 경우만 해제함
* 중앙 저장소 (Redis, Zookeeper, DB 등)에 락 정보를 저장하여 분산 환경에서 락을 구현
* 분산 락은 여러 서버가 있을 때, 공유 자원에 접근하기 위해 분산 시스템을 통해 락을 관리함 
* 데이터베이스나 애플리케이션에서 관리하는 락과는 달리, 분산 환경에서 락을 걸고 풀 수 있는 기능을 제공하는 시스템을 사용함

> ex) 동작과정 예시
> 
> Redis에서 key 기반 락 시도 (lock:product:1)
>
> 락 획득 시 임계 구역 진입
>
> 비즈니스 로직 처리
>
> 락 해제
>
> 다른 인스턴스는 락 해제 후에만 접근 가능
> 
> 임의의 고유 키를 락 식별자로 사용 (예: "lock:resource1")
>
> 락을 획득하면 TTL(만료 시간)을 설정하여 락을 자동 해제할 수 있도록 함 (Deadlock 방지)
>
> 락을 획득하려는 인스턴스가 Redis에 락 키를 SETNX (Set if Not eXists) 명령으로 저장 시도
>
> 키가 없으면 성공 → 락 획득
>
> 키가 이미 있으면 실패 → 락을 못 얻어 대기 혹은 재시도
>
> 락을 획득한 인스턴스만이 공유 자원(예: 데이터 수정 작업)을 안전하게 수행 가능
>
> 작업이 끝나면 락 키를 삭제해 락 해제
> 
> 락이 해제되면 다른 인스턴스들이 다시 락 획득 시도 가능
> 
> 여러 서버/인스턴스가 하나의 자원에 동시 접근하지 않도록 Redis에 락 키를 저장하는 방법으로 락 관리
> 
> 락 키를 가진 인스턴스만 안전하게 자원 작업 수행 가능
> 
> 락 키 없으면 대기하거나 재시도
> 
> 락 키는 TTL 설정으로 자동 만료 가능해 데드락 예방
> 
> 락을 가진 요청이 작업 완료 후 락 키를 삭제
>
> 락 키가 없어지면 대기 중인 요청 중에서 다시 1개가 락 획득 시도
>
> 이 과정이 계속 반복돼서 순차적으로 처리됨
> 
> TTL이 너무 짧으면 락을 가진 작업이 끝나기 전에 락이 만료될 수 있음
> 
> 그러면 다른 요청이 락 키를 획득하고 중복 작업 또는 데이터 충돌이 발생할 수 있음 → 데드락과 동시에 데이터 무결성 위험 발생
>
> TTL은 작업이 최대 소요될 시간보다 충분히 길어야 함
>
> 예를 들어, 평균 작업시간이 2초라면 TTL은 3~5초 이상으로 여유를 두는 게 안전
>
> 너무 길면 락이 오래 잠겨서 병목 가능, 너무 짧으면 락이 중간에 풀릴 위험
> 
> 락을 오래 잡아야 하는 작업은 TTL 만료 전에 락을 갱신하는 "락 연장" 기법 사용 가능
>
> 예: 일정 시간마다 락 키 TTL을 연장하는 별도 스레드나 타이머 운영



| 항목          | 비관적 락                         | 낙관적 락                          | 분산 락                          |
|---------------|----------------------------------|-----------------------------------|----------------------------------|
| **락 위치**     | DB 레벨                          | 애플리케이션 레벨 (`@Version`)     | 외부 시스템 (ex. Redis)          |
| **충돌 감지 방법** | 데이터 자체를 락으로 차단            | 버전 불일치 감지                   | 외부 자원으로 락 키 관리          |
| **성능**       | 충돌 많을 땐 안정적, 낮을 땐 느림       | 충돌 적을 때 빠름                  | 락 관리 오버헤드 존재             |
| **사용 시점**    | 재고, 금액 등 중요한 업데이트         | 충돌 가능성 낮은 CRUD              | 분산 서버 간 공유 자원 접근 시     |
| **주 사용 환경**   | 동시성 충돌 가능성이 매우 높은 상황, 데이터 무결성이 최우선이고, 충돌 발생 시 실패 비용이 큰 경우     | 충돌 가능성이 적고, 대부분 데이터가 충돌 없이 처리되는 경우, 사용자 편의성 및 성능이 중요하며, 충돌 시 재시도 로직으로 해결 가능할 때    | 서버가 여러 대(분산 환경)이고, 공유 자원(데이터, API, 파일 등)에 동시에 접근해야 할 때, 데이터베이스 락만으로는 부족하고, 여러 인스턴스 간 락 조율이 필요할 때|
| **사용 예시**   | 은행 금융 시스템, 재고 관리 시스템, 예약 시스템   | SMS 게시글, 댓글 수정, 회원 정보 수정      | 배치 작업 스케줄러 중복 실행 방지, 분산 파일 시스템에서 파일 접근 제어, 마이크로서비스 간 자원 공유    |